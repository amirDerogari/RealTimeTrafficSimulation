package com.team.trafficsimulation.model;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

/**
 * The {@code NetXMLParser} class is a static utility responsible for parsing SUMO Network files (.net.xml).
 * <p>
 * It uses the Java DOM (Document Object Model) parser to read the XML structure and converts
 * the XML elements (junctions, edges, lanes) into the application's internal data model
 * {@link MapData}.
 * </p>
 */
public class NetXMLParser {

    /**
     * Parses a SUMO network file and constructs a {@link MapData} object containing the topology.
     * <p>
     * This method filters out "internal" SUMO elements (junctions or edges starting with ":"),
     * which are used for micro-simulation of intersections but are often unnecessary for
     * macro-level visualization.
     * </p>
     *
     * @param filePath The absolute or relative path to the {@code .net.xml} file.
     * @return A populated {@link MapData} object containing nodes and edges.
     * @throws Exception If the file cannot be found, or if an XML parsing error occurs.
     */
    public static MapData parse(String filePath) throws Exception {
        MapData mapData = new MapData();

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.parse(new File(filePath));
        doc.getDocumentElement().normalize();

        // --- Parse Junctions (Nodes) ---
        NodeList nodeElements = doc.getElementsByTagName("junction");
        for (int i = 0; i < nodeElements.getLength(); i++) {
            Element nodeEl = (Element) nodeElements.item(i);
            String id = nodeEl.getAttribute("id");

            // Skip internal junctions generated by SUMO
            if (id.startsWith(":")) continue;

            double x = Double.parseDouble(nodeEl.getAttribute("x"));
            double y = Double.parseDouble(nodeEl.getAttribute("y"));
            mapData.getNodes().add(new SumoNode(id, x, y));
        }

        // --- Parse Edges (Roads) ---
        NodeList edgeElements = doc.getElementsByTagName("edge");
        for (int i = 0; i < edgeElements.getLength(); i++) {
            Element edgeEl = (Element) edgeElements.item(i);
            String id = edgeEl.getAttribute("id");
            String from = edgeEl.getAttribute("from");
            String to = edgeEl.getAttribute("to");

            // Skip internal edges (connections inside junctions)
            if (id.startsWith(":")) continue;

            NodeList laneElements = edgeEl.getElementsByTagName("lane");
            List<SumoLane> lanes = new ArrayList<>();

            // --- Parse Lanes within the Edge ---
            for (int j = 0; j < laneElements.getLength(); j++) {
                Element laneEl = (Element) laneElements.item(j);

                String widthStr = laneEl.getAttribute("width");
                String shapeStr = laneEl.getAttribute("shape");

                double width;
                if (widthStr.trim().isEmpty()) {
                    width = 3.0;
                    System.err.println("Warning: Lane width is missing/empty. Using default: 3.0m.");
                } else {
                    width = Double.parseDouble(widthStr);
                }

                List<Double> shapeX = new ArrayList<>();
                List<Double> shapeY = new ArrayList<>();

                // Parse the shape coordinate string "x1,y1 x2,y2 ..."
                if (!shapeStr.trim().isEmpty()) {
                    String[] points = shapeStr.split(" ");
                    for (String point : points) {
                        if (point.trim().isEmpty()) continue;

                        String[] coords = point.split(",");

                        if (coords.length == 2 && !coords[0].trim().isEmpty() && !coords[1].trim().isEmpty()) {
                            try {
                                shapeX.add(Double.parseDouble(coords[0].trim()));
                                shapeY.add(Double.parseDouble(coords[1].trim()));
                            } catch (NumberFormatException e) {
                                System.err.println("Error parsing shape coordinate: " + point + " in lane " + laneEl.getAttribute("id"));
                            }
                        }
                    }
                }

                lanes.add(new SumoLane(laneEl.getAttribute("id"), width, shapeX, shapeY));
            }

            mapData.getEdges().add(new SumoEdge(id, from, to, lanes));
        }

        return mapData;
    }
}
